#ifndef __ProjektGFKMainFrame__
#define __ProjektGFKMainFrame__

/**
@file
Subclass of MainFrame, which is generated by wxFormBuilder.
*/

#include "GUI.h"

//// end generated include
#include "ProjektGFKRangeDialog.h"
#include <wx/wxprec.h>
#include <wx/dcmemory.h>
#include <wx/dcclient.h>
#include <wx/dcbuffer.h>
#include <wx/sizer.h>
#include <wx/panel.h>
#include <wx/graphics.h>
#include <wx/timer.h>

#include <fstream>

#include <vector>
#include <sstream>
#include <map>

/*

	Projekt GFK: 38 Interpreter grafiki wektorowej
	
	Autorzy:
	Hubert Jakubek
	Piotr Brunarski
	Maciej Bolsega

*/

class vec
{
public:
	vec(double _x, double _y) : x(_x), y(_y) {}

	void X(double _x) { x = _x; }
	void Y(double _y) { y = _y; }
	double& X() { return x; }
	double& Y() { return y; }

	wxPoint GetPoint() { return wxPoint(x, y); }

	void RotateXY(double rads)
	{
		const double oldX = x;
		const double oldY = y;

		x = (oldX)* cos(rads) - (oldY)* sin(rads);
		y = (oldY)* cos(rads) + (oldX)* sin(rads);
	}

	void TransformXY(double Tx, double Ty)
	{
		x += Tx;
		y += Ty;
	}

	void ScaleXY(double Sx, double Sy)
	{
		x *= Sx;
		y *= Sy;
	}
private:
	double x;
	double y;
};

class Shape
{
public:
	Shape() = default;
	Shape(wxColor _color)
	{
		id = lastId;
		idStr = std::to_string(id);
		lastId++;

		Fill(_color);
	}

	void DrawShape(wxBufferedDC* dc, int w, int h)
	{
		double Sx = (double)w / (x1 - x0);
		double Sy = (double)h / (y1 - y0);

		DrawShape(dc, Sx, Sy);
	};
	void virtual DrawShape(wxBufferedDC* dc, double Sx, double Sy) {};
	void virtual Fill(wxColor _color)
	{
		color = _color;

		wxColor temp(255 - color.Red(), 255 - color.Blue(), 255 - color.Green());
		showColor.SetRGB(temp.GetRGB());
	}

	void Show(wxTimer& timer)
	{
		show = true;
		timer.Start(showDuration);
	}

	void Hide()
	{
		show = false;
	}

	void UpdatePanelSize(double _x0, double _y0, double _x1, double _y1) { x0 = _x0; y0 = _y0; x1 = _x1; y1 = _y1; };

	std::string GetIdText() { return idText; }
	std::string GetId() { return idStr; }

	void Move(double x, double y) { transformX += x; transformY += y; }
	void Rotate(double angle, double x = 0, double y = 0) { rotateX = x; rotateY = y; rotateAngle = angle; }

	static int lastId;

	double transformX = 0;
	double transformY = 0;

	double rotateX = 0;
	double rotateY = 0;
	double rotateAngle = 0;

	wxColor color;
protected:
	bool show = false;

	wxColor showColor;
	int showDuration = 500;

	std::string idText;
	std::string idStr;
	int id;

	double x0 = 0;
	double x1 = 1;
	double y0 = 0;
	double y1 = 1;
};

class RectangleShape : public Shape
{
public:
	RectangleShape(double _xl, double _yl, double _xr, double _yr, wxColor _color) : Shape(_color), xl(_xl), yl(_yl), xr(_xr), yr(_yr)
	{
		idText = "Rectangle" + std::to_string(id);
	}

	void DrawShape(wxBufferedDC* dc, double Sx, double Sy) override
	{
		double rotateRadians = -rotateAngle * M_PI / 180.0;

		dc->SetPen(wxColor(0, 0, 0));
		dc->SetBrush(color);
		if (show) dc->SetBrush(showColor);

		std::vector<vec> vertices = { vec(xl, yl), vec(xl, yr), vec(xr, yr), vec(xr, yl) };

		for (auto&& vertice : vertices)
		{
			vertice.TransformXY(transformX, transformY);
			vertice.TransformXY(-rotateX, -rotateY);
			vertice.RotateXY(rotateRadians);
			vertice.TransformXY(rotateX, rotateY);

			vertice.TransformXY(-x0, -y0);

			vertice.ScaleXY(Sx, Sy);
		}

		wxPoint points[4] = { vertices[0].GetPoint(), vertices[1].GetPoint(), vertices[2].GetPoint(), vertices[3].GetPoint() };
		dc->DrawPolygon(4, points);
	}

	double xl;
	double xr;
	double yl;
	double yr;
};

class LineShape : public Shape
{
public:
	LineShape(double _xl, double _yl, double _xr, double _yr, wxColor _color) : Shape(_color), xl(_xl), yl(_yl), xr(_xr), yr(_yr)
	{
		idText = "Line" + std::to_string(id);
	}

	void DrawShape(wxBufferedDC* dc, double Sx, double Sy) override
	{
		double rotateRadians = -rotateAngle * M_PI / 180.0;

		dc->SetPen(color);
		dc->SetBrush(*wxTRANSPARENT_BRUSH);
		if (show) dc->SetPen(showColor);

		std::vector<vec> vertices = { vec(xl, yl), vec(xr, yr) };

		for (auto&& vertice : vertices)
		{
			vertice.TransformXY(transformX, transformY);

			vertice.TransformXY(-rotateX, -rotateY);
			vertice.RotateXY(rotateRadians);
			vertice.TransformXY(rotateX, rotateY);

			vertice.TransformXY(-x0, -y0);
			vertice.ScaleXY(Sx, Sy);
		}

		wxPoint points[2] = { vertices[0].GetPoint(), vertices[1].GetPoint() };
		dc->DrawLine(points[0], points[1]);
	}

	double xl;
	double xr;
	double yl;
	double yr;
};

class CircleShape : public Shape
{
public:
	CircleShape(double _x, double _y, double _r, wxColor _color) : Shape(_color), x(_x), y(_y), r(_r)
	{
		idText = "Circle" + std::to_string(id);
	}

	void DrawShape(wxBufferedDC* dc, double Sx, double Sy) override
	{
		double rotateRadians = -rotateAngle * M_PI / 180.0;

		dc->SetPen(wxColor(0, 0, 0));
		dc->SetBrush(color);
		if (show) dc->SetBrush(showColor);

		double R = r * (Sx > Sy ? Sy : Sx);

		vec center = vec(x, y);

		center.TransformXY(transformX, transformY);

		center.TransformXY(-rotateX, -rotateY);
		center.RotateXY(rotateRadians);
		center.TransformXY(rotateX, rotateY);

		center.TransformXY(-x0, -y0);
		center.ScaleXY(Sx, Sy);

		dc->DrawCircle(center.GetPoint(), R);
	}

	double x;
	double y;
	double r;
};

class EllipseShape : public Shape
{
public:
	EllipseShape(double _x, double _y, double _rx, double _ry, wxColor _color) : Shape(_color), x(_x), y(_y), rx(_rx), ry(_ry)
	{
		idText = "Ellipse" + std::to_string(id);
	}

	void DrawShape(wxBufferedDC* dc, double Sx, double Sy) override
	{
		double rotateRadians = -rotateAngle * M_PI / 180.0;

		dc->SetPen(wxColor(0, 0, 0));
		dc->SetBrush(color);
		if (show) dc->SetBrush(showColor);

		double width = rx / 2.0;
		double height = ry / 2.0;

		const int maxPoints = 50;
		double step = M_PI * 2.0 / maxPoints;

		std::vector<vec> ellipse;

		for (double angle = 0; angle < M_PI * 2.0; angle += step)
		{
			vec point(x + width * cos(angle), y + height * sin(angle));
			ellipse.insert(ellipse.end(), point);
		}

		wxPoint points[maxPoints];

		int i = 0;
		for (auto&& ellipsePoint : ellipse)
		{
			ellipsePoint.TransformXY(transformX, transformY);

			ellipsePoint.TransformXY(-rotateX, -rotateY);
			ellipsePoint.RotateXY(rotateRadians);
			ellipsePoint.TransformXY(rotateX, rotateY);

			ellipsePoint.TransformXY(-x0, -y0);
			ellipsePoint.ScaleXY(Sx, Sy);

			points[i] = ellipsePoint.GetPoint();
			i++;
		}

		dc->DrawPolygon(maxPoints, points);
	}

	double x;
	double y;
	double rx;
	double ry;
};

class ArcShape : public Shape
{
public:
	ArcShape(double _x, double _y, double _rx, double _ry, double _b, double _e) : Shape(wxColor(0, 0, 0)), x(_x), y(_y), rx(_rx), ry(_ry), beginAngle(_b), endAngle(_e)
	{
		idText = "Arc" + std::to_string(id);
	}

	void DrawShape(wxBufferedDC* dc, double Sx, double Sy) override
	{
		double rotateRadians = -rotateAngle * M_PI / 180.0;

		dc->SetPen(wxColor(0, 0, 0));
		dc->SetBrush(wxColor(0, 0, 0));
		if (show) dc->SetBrush(wxColor(255, 255, 255));

		double width = rx / 2.0;
		double height = ry / 2.0;

		const int maxPoints = 50;
		double beginRadians = beginAngle * M_PI / 180.0;
		double endRadians = endAngle * M_PI / 180.0;
		double step = abs(endRadians - beginRadians) / maxPoints;

		std::vector<vec> ellipse;

		for (double angle = beginRadians; angle < endRadians + M_PI / 180.0; angle += step)
		{
			vec point(x + width * cos(-angle), y + height * sin(-angle));
			ellipse.insert(ellipse.end(), point);
		}

		wxPoint points[maxPoints + 1];

		int i = 0;
		for (auto&& ellipsePoint : ellipse)
		{
			ellipsePoint.TransformXY(transformX, transformY);

			ellipsePoint.TransformXY(-rotateX, -rotateY);
			ellipsePoint.RotateXY(rotateRadians);
			ellipsePoint.TransformXY(rotateX, rotateY);

			ellipsePoint.TransformXY(-x0, -y0);
			ellipsePoint.ScaleXY(Sx, Sy);

			points[i] = ellipsePoint.GetPoint();
			i++;
		}

		dc->DrawLines(maxPoints + 1, points);
	}

	double x;
	double y;
	double rx;
	double ry;
	double beginAngle;
	double endAngle;
};

/** Implementing MainFrame */
class ProjektGFKMainFrame : public MainFrame
{
protected:
	// Handlers for MainFrame events.
	void shapeListItemSelected(wxCommandEvent& event);
	void shapeListOnRightDown(wxMouseEvent& event);
	void OnMouseMoved(wxMouseEvent& event);
	void OnPaint(wxPaintEvent& event);
	void OnResizeDrawingPanel(wxSizeEvent& event);
	void DrawingPanelRepaint(wxUpdateUIEvent& event);
	void OnCommandEnter(wxCommandEvent& event);
	void openFileMenuItemSelected(wxCommandEvent& event);
	void saveFileMenuItemSelected(wxCommandEvent& event);
	void saveImageMenuItemSelected(wxCommandEvent& event);
	void clearMenuItemSelected(wxCommandEvent& event);
	void rangeMenuItemSelected(wxCommandEvent& event);
public:
	/** Constructor */
	ProjektGFKMainFrame(wxWindow* parent);
	//// end generated class members

	void Repaint();

	void ParseCommand(std::string cmdLine);

	void UpdateShapeList();
	void UpdatePanelSize();
	void UpdateShapeProperties();

	void OnTimer(wxTimerEvent& e);

	void TestCmd(std::vector<std::string> args);
	void RectangleCmd(std::vector<std::string> args);
	void FillCmd(std::vector<std::string> args);
	void DeleteCmd(std::vector<std::string> args);
	void RangeCmd(std::vector<std::string> args);
	void BackgroundCmd(std::vector<std::string> args);
	void LineCmd(std::vector<std::string> args);
	void CircleCmd(std::vector<std::string> args);
	void EllipseCmd(std::vector<std::string> args);
	void ArcCmd(std::vector<std::string> args);
	void ClearCmd(std::vector<std::string> args);
	void MoveCmd(std::vector<std::string> args);
	void RotateCmd(std::vector<std::string> args);
	void ShowCmd(std::vector<std::string> args);
	void SaveCmd(std::vector<std::string> args);
	void WriteCmd(std::vector<std::string> args);
	void ReadCmd(std::vector<std::string> args);

	void DeleteMenu(wxCommandEvent& event);

private:
	std::map<std::string, void(ProjektGFKMainFrame::*)(std::vector<std::string>)> commandList;
	std::vector<Shape*> shapes;

	int lastShapeIndex = 0;

	double x0 = 0;
	double y0 = 0;
	double x1 = 1;
	double y1 = 1;

	wxColor backgroundColor;

	wxBitmap screenBufferBitmap;
	wxImage screenBufferImg;

	std::string cmdBuffer;

	wxTimer timer;

	Shape* selectedShape = nullptr;







};

#endif // __ProjektGFKMainFrame__
